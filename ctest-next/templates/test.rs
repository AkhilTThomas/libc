/* This file was autogenerated by ctest; do not modify directly */
{#- â†‘ Doesn't apply here, this is the template! +#}

{%- let ctx = self.template +%}

/// As this file is sometimes built using rustc, crate level attributes
/// are not allowed at the top-level, so we hack around this by keeping it
/// inside of a module.
mod generated_tests {
    #![allow(non_snake_case)]
    #![deny(improper_ctypes_definitions)]
    use std::ffi::CStr;
    use std::fmt::{Debug, LowerHex};
    use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
    use std::{mem, ptr, slice};

    use super::*;

    pub static FAILED: AtomicBool = AtomicBool::new(false);
    pub static NTESTS: AtomicUsize = AtomicUsize::new(0);

    /// Check that the value returned from the Rust and C side in a certain test is equivalent.
    ///
    /// Internally it will remember which checks failed and how many tests have been run.
    fn check_same<T: PartialEq + Debug>(rust: T, c: T, attr: &str) {
        if rust != c {
            eprintln!("bad {attr}: rust: {rust:?} != c {c:?}");
            FAILED.store(true, Ordering::Relaxed);
        } else {
            NTESTS.fetch_add(1, Ordering::Relaxed);
        }
    }

    /// Check that the value returned from the Rust and C side in a certain test is equivalent.
    ///
    /// Internally it will remember which checks failed and how many tests have been run. This
    /// method is the same as `check_same` but prints errors in bytes in hex.
    fn check_same_hex<T: PartialEq + LowerHex + Debug>(rust: T, c: T, attr: &str) {
        if rust != c {
            eprintln!("bad {attr}: rust: {rust:?} ({rust:#x}) != c {c:?} ({c:#x})");
            FAILED.store(true, Ordering::Relaxed);
        } else {
            NTESTS.fetch_add(1, Ordering::Relaxed);
        }
    }

{%- for const_cstr in ctx.const_cstr_tests +%}

    // Test that the string constant is the same in both Rust and C.
    // While fat pointers can't be translated, we instead use * const c_char.
    pub fn {{ const_cstr.test_name }}() {
        extern "C" {
            fn ctest_const_cstr__{{ const_cstr.id }}() -> *const c_char;
        }

        // SAFETY: we assume that `c_char` pointer consts are for C strings.
        let r_val = unsafe {
            let r_ptr: *const c_char = {{ const_cstr.rust_val }};
            assert!(!r_ptr.is_null(), "const {{ const_cstr.rust_val }} is null");
            CStr::from_ptr(r_ptr)
        };

        // SAFETY: FFI call returns a valid C string.
        let c_val = unsafe {
            let c_ptr: *const c_char = unsafe { ctest_const_cstr__{{ const_cstr.id }}()  };
            CStr::from_ptr(c_ptr)
        };

        check_same(r_val, c_val, "const {{ const_cstr.rust_val }} string");
    }
{%- endfor +%}

{%- for constant in ctx.const_tests +%}

    // Test that the value of the constant is the same in both Rust and C.
    // This performs a byte by byte comparision of the constant value.
    pub fn {{ constant.test_name }}() {
        type T = {{ constant.rust_ty }};
        extern "C" {
            fn ctest_const__{{ constant.id }}() -> *const T;
        }

        /* HACK: The slices may contian uninitialized data! We do this because
         * there isn't a good way to recursively iterate all fields. */

        let r_val: T = {{ constant.rust_val }};
        let r_bytes = unsafe {
            slice::from_raw_parts(ptr::from_ref(&r_val).cast::<u8>(), size_of::<T>())
        };

        let c_bytes = unsafe {
            let c_ptr: *const T = unsafe { ctest_const__{{ constant.id }}() };
            slice::from_raw_parts(c_ptr.cast::<u8>(), size_of::<T>())
        };

        for (i, (&b1, &b2)) in r_bytes.iter().zip(c_bytes.iter()).enumerate() {
            check_same_hex(b1, b2, &format!("{{ constant.rust_val }} value at byte {}", i));
        }
    }
{%- endfor +%}

{%- for item in ctx.size_align_tests +%}

    /// Compare the size and alignment of the type in Rust and C, making sure they are the same.
    pub fn {{ item.test_name }}() {
        extern "C" {
            fn ctest_size_of__{{ item.id }}() -> u64;
            fn ctest_align_of__{{ item.id }}() -> u64;
        }

        let rust_size = size_of::<{{ item.rust_ty }}>() as u64;
        let c_size = unsafe { ctest_size_of__{{ item.id }}() };

        let rust_align = align_of::<{{ item.rust_ty }}>() as u64;
        let c_align = unsafe { ctest_align_of__{{ item.id }}() };

        check_same(rust_size, c_size, "{{ item.id }} size");
        check_same(rust_align, c_align, "{{ item.id }} align");
    }
{%- endfor +%}

{%- for alias in ctx.signededness_tests +%}

    /// Make sure that the signededness of a type alias in Rust and C is the same.
    ///
    /// This is done by casting 0 to that type and flipping all of its bits. For unsigned types,
    /// this would result in a value larger than zero. For signed types, this results in a value
    /// smaller than 0.
    pub fn {{ alias.test_name }}() {
         extern "C" {
            fn ctest_signededness_of__{{ alias.id }}() -> u32;
        }
        let all_ones = !(0 as {{ alias.id }});
        let all_zeros = 0 as {{ alias.id }};
        let c_is_signed = unsafe { ctest_signededness_of__{{ alias.id }}() };

        check_same((all_ones < all_zeros) as u32, c_is_signed, "{{ alias.id }} signed");
    }
{%- endfor +%}
}

use generated_tests::*;

fn main() {
    println!("RUNNING ALL TESTS");
    run_all();
    if FAILED.load(std::sync::atomic::Ordering::Relaxed) {
        panic!("some tests failed");
    } else {
        println!(
            "PASSED {} tests",
            NTESTS.load(std::sync::atomic::Ordering::Relaxed)
        );
    }
}

// Run all tests by calling the functions that define them.
fn run_all() {
    {%- for test in ctx.test_idents +%}
    {{ test }}();
    {%- endfor +%}
}
