/* This file was autogenerated by ctest; do not modify directly */

/// As this file is sometimes built using rustc, crate level attributes
/// are not allowed at the top-level, so we hack around this by keeping it
/// inside of a module.
mod generated_tests {
    #![allow(non_snake_case)]
    #![deny(improper_ctypes_definitions)]
    use std::ffi::{CStr, c_char};
    use std::fmt::{Debug, LowerHex};
    use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
    #[allow(unused_imports)]
    use std::{mem, ptr, slice};
    #[allow(unused_imports)]
    use std::mem::{MaybeUninit, offset_of};

    use super::*;

    pub static FAILED: AtomicBool = AtomicBool::new(false);
    pub static NTESTS: AtomicUsize = AtomicUsize::new(0);

    /// Check that the value returned from the Rust and C side in a certain test is equivalent.
    ///
    /// Internally it will remember which checks failed and how many tests have been run.
    fn check_same<T: PartialEq + Debug>(rust: T, c: T, attr: &str) {
        if rust != c {
            eprintln!("bad {attr}: rust: {rust:?} != c {c:?}");
            FAILED.store(true, Ordering::Relaxed);
        } else {
            NTESTS.fetch_add(1, Ordering::Relaxed);
        }
    }

    /// Check that the value returned from the Rust and C side in a certain test is equivalent.
    ///
    /// Internally it will remember which checks failed and how many tests have been run. This
    /// method is the same as `check_same` but prints errors in bytes in hex.
    fn check_same_hex<T: PartialEq + LowerHex + Debug>(rust: T, c: T, attr: &str) {
        if rust != c {
            eprintln!("bad {attr}: rust: {rust:?} ({rust:#x}) != c {c:?} ({c:#x})");
            FAILED.store(true, Ordering::Relaxed);
        } else {
            NTESTS.fetch_add(1, Ordering::Relaxed);
        }
    }

    // Test that the string constant is the same in both Rust and C.
    // While fat pointers can't be translated, we instead use * const c_char.
    pub fn ctest_const_cstr_A() {
        extern "C" {
            fn ctest_const_cstr__A() -> *const c_char;
        }

        // SAFETY: we assume that `c_char` pointer consts are for C strings.
        let r_val = unsafe {
            let r_ptr: *const c_char = A;
            assert!(!r_ptr.is_null(), "const A is null");
            CStr::from_ptr(r_ptr)
        };

        // SAFETY: FFI call returns a valid C string.
        let c_val = unsafe {
            let c_ptr: *const c_char = ctest_const_cstr__A();
            CStr::from_ptr(c_ptr)
        };

        check_same(r_val, c_val, "const A string");
    }

    /// Compare the size and alignment of the type in Rust and C, making sure they are the same.
    pub fn ctest_size_align_Byte() {
        extern "C" {
            fn ctest_size_of__Byte() -> u64;
            fn ctest_align_of__Byte() -> u64;
        }

        let rust_size = size_of::<Byte>() as u64;
        let c_size = unsafe { ctest_size_of__Byte() };

        let rust_align = align_of::<Byte>() as u64;
        let c_align = unsafe { ctest_align_of__Byte() };

        check_same(rust_size, c_size, "Byte size");
        check_same(rust_align, c_align, "Byte align");
    }

    /// Compare the size and alignment of the type in Rust and C, making sure they are the same.
    pub fn ctest_size_align_Person() {
        extern "C" {
            fn ctest_size_of__Person() -> u64;
            fn ctest_align_of__Person() -> u64;
        }

        let rust_size = size_of::<Person>() as u64;
        let c_size = unsafe { ctest_size_of__Person() };

        let rust_align = align_of::<Person>() as u64;
        let c_align = unsafe { ctest_align_of__Person() };

        check_same(rust_size, c_size, "Person size");
        check_same(rust_align, c_align, "Person align");
    }

    /// Compare the size and alignment of the type in Rust and C, making sure they are the same.
    pub fn ctest_size_align_Word() {
        extern "C" {
            fn ctest_size_of__Word() -> u64;
            fn ctest_align_of__Word() -> u64;
        }

        let rust_size = size_of::<Word>() as u64;
        let c_size = unsafe { ctest_size_of__Word() };

        let rust_align = align_of::<Word>() as u64;
        let c_align = unsafe { ctest_align_of__Word() };

        check_same(rust_size, c_size, "Word size");
        check_same(rust_align, c_align, "Word align");
    }

    /// Make sure that the signededness of a type alias in Rust and C is the same.
    ///
    /// This is done by casting 0 to that type and flipping all of its bits. For unsigned types,
    /// this would result in a value larger than zero. For signed types, this results in a value
    /// smaller than 0.
    pub fn ctest_signededness_Byte() {
         extern "C" {
            fn ctest_signededness_of__Byte() -> u32;
        }
        let all_ones = !(0 as Byte);
        let all_zeros = 0 as Byte;
        let c_is_signed = unsafe { ctest_signededness_of__Byte() };

        check_same((all_ones < all_zeros) as u32, c_is_signed, "Byte signed");
    }

    /// Make sure that the offset and size of a field in a struct/union is the same.
    pub fn ctest_field_size_offset_Person_name() {
        extern "C" {
            fn ctest_offset_of__Person__name() -> u64;
            fn ctest_size_of__Person__name() -> u64;
        }

        let uninit_ty = MaybeUninit::<Person>::zeroed();
        let uninit_ty = uninit_ty.as_ptr();

        // SAFETY: we assume the field access doesn't wrap
        let ty_ptr = unsafe { &raw const (*uninit_ty).name   };
        // SAFETY: we assume that all zeros is a valid bitpattern for `ty_ptr`, otherwise the
        // test should be skipped.
        let val = unsafe { ty_ptr.read_unaligned() };

        // SAFETY: FFI call with no preconditions
        let ctest_field_offset = unsafe { ctest_offset_of__Person__name() };
        check_same(offset_of!(Person, name) as u64, ctest_field_offset,
            "field offset name of Person");
        // SAFETY: FFI call with no preconditions
        let ctest_field_size = unsafe { ctest_size_of__Person__name() };
        check_same(size_of_val(&val) as u64, ctest_field_size,
            "field size name of Person");
    }

    /// Make sure that the offset and size of a field in a struct/union is the same.
    pub fn ctest_field_size_offset_Person_age() {
        extern "C" {
            fn ctest_offset_of__Person__age() -> u64;
            fn ctest_size_of__Person__age() -> u64;
        }

        let uninit_ty = MaybeUninit::<Person>::zeroed();
        let uninit_ty = uninit_ty.as_ptr();

        // SAFETY: we assume the field access doesn't wrap
        let ty_ptr = unsafe { &raw const (*uninit_ty).age   };
        // SAFETY: we assume that all zeros is a valid bitpattern for `ty_ptr`, otherwise the
        // test should be skipped.
        let val = unsafe { ty_ptr.read_unaligned() };

        // SAFETY: FFI call with no preconditions
        let ctest_field_offset = unsafe { ctest_offset_of__Person__age() };
        check_same(offset_of!(Person, age) as u64, ctest_field_offset,
            "field offset age of Person");
        // SAFETY: FFI call with no preconditions
        let ctest_field_size = unsafe { ctest_size_of__Person__age() };
        check_same(size_of_val(&val) as u64, ctest_field_size,
            "field size age of Person");
    }

    /// Make sure that the offset and size of a field in a struct/union is the same.
    pub fn ctest_field_size_offset_Person_job() {
        extern "C" {
            fn ctest_offset_of__Person__job() -> u64;
            fn ctest_size_of__Person__job() -> u64;
        }

        let uninit_ty = MaybeUninit::<Person>::zeroed();
        let uninit_ty = uninit_ty.as_ptr();

        // SAFETY: we assume the field access doesn't wrap
        let ty_ptr = unsafe { &raw const (*uninit_ty).job   };
        // SAFETY: we assume that all zeros is a valid bitpattern for `ty_ptr`, otherwise the
        // test should be skipped.
        let val = unsafe { ty_ptr.read_unaligned() };

        // SAFETY: FFI call with no preconditions
        let ctest_field_offset = unsafe { ctest_offset_of__Person__job() };
        check_same(offset_of!(Person, job) as u64, ctest_field_offset,
            "field offset job of Person");
        // SAFETY: FFI call with no preconditions
        let ctest_field_size = unsafe { ctest_size_of__Person__job() };
        check_same(size_of_val(&val) as u64, ctest_field_size,
            "field size job of Person");
    }

    /// Make sure that the offset and size of a field in a struct/union is the same.
    pub fn ctest_field_size_offset_Word_word() {
        extern "C" {
            fn ctest_offset_of__Word__word() -> u64;
            fn ctest_size_of__Word__word() -> u64;
        }

        let uninit_ty = MaybeUninit::<Word>::zeroed();
        let uninit_ty = uninit_ty.as_ptr();

        // SAFETY: we assume the field access doesn't wrap
        let ty_ptr = unsafe { &raw const (*uninit_ty).word   };
        // SAFETY: we assume that all zeros is a valid bitpattern for `ty_ptr`, otherwise the
        // test should be skipped.
        let val = unsafe { ty_ptr.read_unaligned() };

        // SAFETY: FFI call with no preconditions
        let ctest_field_offset = unsafe { ctest_offset_of__Word__word() };
        check_same(offset_of!(Word, word) as u64, ctest_field_offset,
            "field offset word of Word");
        // SAFETY: FFI call with no preconditions
        let ctest_field_size = unsafe { ctest_size_of__Word__word() };
        check_same(size_of_val(&val) as u64, ctest_field_size,
            "field size word of Word");
    }

    /// Make sure that the offset and size of a field in a struct/union is the same.
    pub fn ctest_field_size_offset_Word_byte() {
        extern "C" {
            fn ctest_offset_of__Word__byte() -> u64;
            fn ctest_size_of__Word__byte() -> u64;
        }

        let uninit_ty = MaybeUninit::<Word>::zeroed();
        let uninit_ty = uninit_ty.as_ptr();

        // SAFETY: we assume the field access doesn't wrap
        let ty_ptr = unsafe { &raw const (*uninit_ty).byte   };
        // SAFETY: we assume that all zeros is a valid bitpattern for `ty_ptr`, otherwise the
        // test should be skipped.
        let val = unsafe { ty_ptr.read_unaligned() };

        // SAFETY: FFI call with no preconditions
        let ctest_field_offset = unsafe { ctest_offset_of__Word__byte() };
        check_same(offset_of!(Word, byte) as u64, ctest_field_offset,
            "field offset byte of Word");
        // SAFETY: FFI call with no preconditions
        let ctest_field_size = unsafe { ctest_size_of__Word__byte() };
        check_same(size_of_val(&val) as u64, ctest_field_size,
            "field size byte of Word");
    }

    /// Tests if the pointer to the field is the same in Rust and C.
    pub fn ctest_field_ptr_Person_name() {
        extern "C" {
            fn ctest_field_ptr__Person__name(a: *const Person) -> *mut u8;
        }

        let uninit_ty = MaybeUninit::<Person>::zeroed();
        let ty_ptr = uninit_ty.as_ptr();
        // SAFETY: We don't read `field_ptr`, only compare the pointer itself.
        // The assumption is made that this does not wrap the address space.
        let field_ptr = unsafe { &raw const ((*ty_ptr).name) };

        // SAFETY: FFI call with no preconditions
        let ctest_field_ptr = unsafe { ctest_field_ptr__Person__name(ty_ptr) };
        check_same(field_ptr.cast(), ctest_field_ptr,
            "field type name of Person");
    }

    /// Tests if the pointer to the field is the same in Rust and C.
    pub fn ctest_field_ptr_Person_age() {
        extern "C" {
            fn ctest_field_ptr__Person__age(a: *const Person) -> *mut u8;
        }

        let uninit_ty = MaybeUninit::<Person>::zeroed();
        let ty_ptr = uninit_ty.as_ptr();
        // SAFETY: We don't read `field_ptr`, only compare the pointer itself.
        // The assumption is made that this does not wrap the address space.
        let field_ptr = unsafe { &raw const ((*ty_ptr).age) };

        // SAFETY: FFI call with no preconditions
        let ctest_field_ptr = unsafe { ctest_field_ptr__Person__age(ty_ptr) };
        check_same(field_ptr.cast(), ctest_field_ptr,
            "field type age of Person");
    }

    /// Tests if the pointer to the field is the same in Rust and C.
    pub fn ctest_field_ptr_Person_job() {
        extern "C" {
            fn ctest_field_ptr__Person__job(a: *const Person) -> *mut u8;
        }

        let uninit_ty = MaybeUninit::<Person>::zeroed();
        let ty_ptr = uninit_ty.as_ptr();
        // SAFETY: We don't read `field_ptr`, only compare the pointer itself.
        // The assumption is made that this does not wrap the address space.
        let field_ptr = unsafe { &raw const ((*ty_ptr).job) };

        // SAFETY: FFI call with no preconditions
        let ctest_field_ptr = unsafe { ctest_field_ptr__Person__job(ty_ptr) };
        check_same(field_ptr.cast(), ctest_field_ptr,
            "field type job of Person");
    }

    /// Tests if the pointer to the field is the same in Rust and C.
    pub fn ctest_field_ptr_Word_word() {
        extern "C" {
            fn ctest_field_ptr__Word__word(a: *const Word) -> *mut u8;
        }

        let uninit_ty = MaybeUninit::<Word>::zeroed();
        let ty_ptr = uninit_ty.as_ptr();
        // SAFETY: We don't read `field_ptr`, only compare the pointer itself.
        // The assumption is made that this does not wrap the address space.
        let field_ptr = unsafe { &raw const ((*ty_ptr).word) };

        // SAFETY: FFI call with no preconditions
        let ctest_field_ptr = unsafe { ctest_field_ptr__Word__word(ty_ptr) };
        check_same(field_ptr.cast(), ctest_field_ptr,
            "field type word of Word");
    }

    /// Tests if the pointer to the field is the same in Rust and C.
    pub fn ctest_field_ptr_Word_byte() {
        extern "C" {
            fn ctest_field_ptr__Word__byte(a: *const Word) -> *mut u8;
        }

        let uninit_ty = MaybeUninit::<Word>::zeroed();
        let ty_ptr = uninit_ty.as_ptr();
        // SAFETY: We don't read `field_ptr`, only compare the pointer itself.
        // The assumption is made that this does not wrap the address space.
        let field_ptr = unsafe { &raw const ((*ty_ptr).byte) };

        // SAFETY: FFI call with no preconditions
        let ctest_field_ptr = unsafe { ctest_field_ptr__Word__byte(ty_ptr) };
        check_same(field_ptr.cast(), ctest_field_ptr,
            "field type byte of Word");
    }
}

use generated_tests::*;

fn main() {
    println!("RUNNING ALL TESTS");
    run_all();
    if FAILED.load(std::sync::atomic::Ordering::Relaxed) {
        panic!("some tests failed");
    } else {
        println!(
            "PASSED {} tests",
            NTESTS.load(std::sync::atomic::Ordering::Relaxed)
        );
    }
}

// Run all tests by calling the functions that define them.
fn run_all() {
    ctest_const_cstr_A();
    ctest_size_align_Byte();
    ctest_size_align_Person();
    ctest_size_align_Word();
    ctest_signededness_Byte();
    ctest_field_size_offset_Person_name();
    ctest_field_size_offset_Person_age();
    ctest_field_size_offset_Person_job();
    ctest_field_size_offset_Word_word();
    ctest_field_size_offset_Word_byte();
    ctest_field_ptr_Person_name();
    ctest_field_ptr_Person_age();
    ctest_field_ptr_Person_job();
    ctest_field_ptr_Word_word();
    ctest_field_ptr_Word_byte();
}
